---
title: "Data Structures"
teaching: 30
exercises: 10
questions:
- "What is a vector in R and how can I manipulate it?"
- "What are the basic data types in R?"
- "How do I represent categorical information in R?"
objectives:
- "To be aware of the different types of data."
- "To begin exploring data frames, and understand how they are related to vectors, factors and lists."
- "To be able to ask questions from R about the type, class, and structure of an object."
keypoints:

- "The basic data types in R are double, integer, complex, logical, and character."
- "Use factors to represent categories in R."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-")
```


## Data Types

If you guessed that the last command will return an error because `2.1 + "black"` is nonsense, you're right - and you already have some intuition for an important concept in programming called *data types*. We can ask what type of data something is with `typeof()`:

```{r}
d <- matrix(1:12, nrow = 3, ncol = 4)
typeof(d)
```

There are 5 main types: `double`, `integer`, `complex`, `logical` and `character`. On a pratical level

```{r}
typeof(3.14)
typeof(1L) # The L suffix forces the number to be an integer, since by default R uses double numbers
typeof(1+1i)
typeof(TRUE)
typeof('banana')
```

No matter how complicated our analyses become, all data in R is interpreted as one of these basic data types. This strictness is a handy thing to rely on. 

One a practical level, most of us only work with 3 data types: numeric (this captures both double and integer), character and logical.

To better understand this behavior, let's meet another of the data structures: the *vector*. 

## Vectors and Type Coercion

Vectors are a collection of elements that have all been "coerced" (forced) to be the same type. When R reads evaluates a vector of elements, it insists that everything in the vector be the same basic type. For example, if it can't understand *everything* in the column as a double, then *no element* in the column gets to be a double. To makes things more interesting, R actually calls these "atomic vectors". 

Okay, let's make some vectors!

```{r}
#declare a vector, but don't fill it
my_vector <- vector(length = 3)
my_vector
```

If you don't choose the datatype, it'll default to `logical`; or, you can declare an empty vector of whatever type you like.

```{r}
another_vector <- vector(mode='character', length=3)
another_vector
```

You can check if something is a vector and it's type:

```{r}
is.vector(another_vector)
typeof(another_vector)
```

Here'a bunch of vector declarations:
```{r}
(vec1 <- 1:10)
(vec2 <- rnorm(10))
(vec3 <- c("tolerant", "susceptible", "resistant"))
(vec4 <- c(T, T, T, F, F, T, F))
(vec5 <- c(TRUE, FALSE, "TRUE", "FALSE"))
(vec6 <- 50L)
```
The function `c()` refers to the combine function - it combines mulitples items into a single vector.  

Let's check of the types of all those vectors
```{r}
typeof(vec1)
typeof(vec2)
typeof(vec3)
typeof(vec4)
typeof(vec5)
typeof(vec6)
```
What happened to vector 5? Why isn't that a logical vector? Because some 

Another dig more into object's structure with the function `str()`:
```{r}
str(vec2)
```
The somewhat cryptic output from this command indicates the basic data type found in this vector - in this case `num`, character; an indication of the number of things in the vector - actually, the indexes of the vector, in this case `[1:10]`; and a few examples of what's actually in the vector - in this case, double-precision numbers. . 

Individual elements in a vector can be accessed by 


> Why is R so opinionated about what we put in our columns of data?
> How does this help us?
>
> >
> > By keeping everything in a column the same, we allow ourselves to make simple
> > assumptions about our data; if you can interpret one entry in the column as a
> > number, then you can interpret *all* of them as numbers, so we don't have to
> > check every time. This consistency is what people mean when they talk about 
> > *clean data*; in the long run, strict consistency goes a long way to making 
> > our lives easier in R.
> {: .solution}
{: .discussion}

Given what we've learned so far, what do you think the following will produce?

```{r}
quiz_vector <- c(2,6,'.')
```

This -- *type coercion* -- is the source of many surprises and the reason why we need to be aware of the basic data types and how R will interpret them. When R encounters a mix of types (here numeric and character) to be combined into a single vector, it will force them all to be the same type. Consider:

```{r}
coercion_vector <- c('a', TRUE)
coercion_vector
typeof(coercion_vector)
another_coercion_vector <- c(0, TRUE)
another_coercion_vector
typeof(another_coercion_vector)
```

The coercion rules go: `logical` -> `integer` -> `numeric` -> `complex` -> `character`, where -> can be read as *are transformed into*. You can try to force coercion against this flow using the `as.()` functions:

```{r}
character_vector_example <- c('0','2','4')
character_vector_example
character_coerced_to_numeric <- as.numeric(character_vector_example)
character_coerced_to_numeric
numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)
numeric_coerced_to_logical
```

As you can see, some surprising things can happen when R forces one basic data type into another! Nitty-gritty of type coercion aside, the point is: if your data doesn't look like what you thought it was going to look like, type coercion may well be to blame; make sure everything is the same type in your vectors and your columns of data to prevent these issues!

But coercion can also be very useful! For example, 1 and 0 actually represent `TRUE` and `FALSE` (a common way of representing them). We should use the `logical` datatype here, which has two states: `TRUE` or `FALSE`, which is exactly what our data represents. We can 'coerce' this column to be `logical` by using the `as.logical` function:

```{r}
my_int <- c(1, 0, 1, 1)
my_logical <- as.logical(my_int)
my_logical
```

The combine function, `c()`, can also be used to append things to an existing vector:

```{r}
ab_vector <- c('a', 'b')
ab_vector
combine_example <- c(ab_vector, 'UIdaho')
combine_example
```

You can also make series of numbers:

```{r}
mySeries <- 1:10
mySeries
seq(10)
seq(0,1, by = 0.1)
```

We can ask a few questions about vectors:

```{r}
sequence_example <- seq(0, 10, by = 0.1) 
head(sequence_example)
head(sequence_example, n = 2)
tail(sequence_example)
length(sequence_example)
 
```

We can look at individual elements in a vector by indexing their position with the square brackets `[ ]`. Indexing starts at 1 for the first element and ends at the length of the vector. Length can be assessed with the function `length()`.

```{r}
mySeries <- -10:10
mySeries[1] #index the first
mySeries[length(mySeries)] #index the last
mySeries[c(1, 3, 5:9)] #index several 
```

Vectors can also be explored with sorting algorithms:
```{r}
rand <- rnorm(50)
sort(rand)
order(rand) #this is actually an index!

sort()
```


Finally, you can give names to elements in your vector:

```{r}
my_example <- 5:8
names(my_example) <- c("a", "b", "c", "d")
my_example
names(my_example)
```

## Factors

Another important specialised data type is called a *factor*. Factors usually look like character data, but are used to represent categorical information - that is a character variable with pre-defined levels. This is important for running linear modelling functions like ANOVA. To makes things even more complicated, they are technically implemented as integers! Let's make a vector of strings labelling disease inoculation treatment. 

```{r}
trt <- c("no_inoc", "strain1", "water_inoc", "strain1", "no_inoc", "water_inoc")

str(trt)
```

We can turn a vector into a factor like so:

```{r}
Trt <- factor(trt)
class(Trt)
typeof(Trt)
```

Now R has noticed that there are three possible categories in our data - but it also did something surprising; instead of printing out the strings we gave it, we got a bunch of integers instead. R has replaced our human-readable categories
with numbered indices under the hood, this is necessary as many statistical calculations utilise such numerical representations for categorical data:

```{r}
str(Trt)
```

Factors are tricky an it's will benefit you to know to manipulate them. The first thing that is helpful to know if how to order factors. In many statistical models, the first level of a factor as set as the baseline and the other levels are compared to that point. In R, the baseline level is first levell, but by default, factors are labelled in alphabetical order. You can change this by specifying the levels:

```{r}
mydata <- c("case", "control", "control", "case")
factor_ordering_example <- factor(mydata, levels = c("control", "case"))
str(factor_ordering_example)
```

In this case, we've explicitly told R that "control" should be represented by 1, and "case" by 2. This designation can be very important for interpreting the results of statistical models! 

There is a fantastic program for manipulating factors on CRAN called `forcats`. 
```{r echo=F, out.width=250, out.height=250}
knitr::include_graphics("../fig/forcats.png")
```


## Lists

Another data structure you'll want in your bag of tricks is the `list`. A list is simpler in some ways than the other types, because you can put anything you want in it:

```{r}
list_example <- list(1, "a", TRUE, 1+4i)
list_example
another_list <- list(title = "Numbers", numbers = 1:10, data = TRUE, list2 = list(1, 2, 3))
another_list
```

Lists are very flexible and helpful. They are like a closet of assorted data types and structures. Lists can be nested in other lists. List items are accessed with the double brackets `[[]]`. 

```{r}
another_list[[3]]
```

Like atomic vectors, lists items can be named and assigned. Above, the names are assigned to items in list "another_list", which we can access:

```{r}
names(another_list)
(numbs <- another_list[[2]])
another_list$numbers
```
The `$` is an important operator in R. In this case, we can use it to access an item in an list. We will talk about this more in this workshop. We will say no more on lists. 
