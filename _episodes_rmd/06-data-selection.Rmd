---
title: Subsetting Data
teaching: 20
exercises: 10
questions:
- "How can I work with subsets of data in R?"
objectives:
- "To be able to subset vectors, factors, matrices, lists, and data frames"
- "To be able to extract individual and multiple elements: by index, by name, using comparison operations"
- "To be able to skip and remove elements from various data structures."
keypoints:
- "Indexing in R starts at 1, not 0."
- "Access individual values by location using `[]`."
- "Access slices of data using `[low:high]`."
- "Access arbitrary sets of data using `[c(...)]`."
- "Use logical operations and logical vectors to access subsets of data."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("06-")
```

R has many powerful subset operators. Mastering them will allow you to easily perform complex operations on any kind of dataset.

There are six different ways we can subset any kind of object, and three different subsetting operators for the different data structures.

Let's start with the workhorse of R: a simple numeric vector.

```{r}
x <- c(5.4, 6.2, 7.1, 4.8, 7.5)
names(x) <- c('a', 'b', 'c', 'd', 'e')
x
```

We are already familiar with how to access the elements via numerical indexing. It's a handy way to quickly access important rows and columns. However, if column  or row order changes in the original data file, set index commands will have unexpected (mostly incorrect) results. 

## Subsetting by name

We can extract elements by using their name, instead of extracting by index:

```{r}
x <- c(a = 5.4, b=6.2, c=7.1, d=4.8, e=7.5) # we can name a vector 'on the fly'
x[c("a", "c")]
```

This is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same!

## Subsetting through other logical operations

We can also use any logical vector to subset. A logical vector must be the same length as vector it will index. It selects all elements designated "TRUE". 

```{r}
bool <- c(FALSE, FALSE, TRUE, FALSE, TRUE)
x[bool]
```

Since comparison operators (e.g. `>`, `<`, `==`) evaluate to logical vectors, we can also
use them to succinctly subset vectors: the following statement gives the same result as the previous one.

```{r}
x[x > 7]
```

Breaking it down, this statement first evaluates `x>7` for each value in x, generating
a logical vector `c(FALSE, FALSE, TRUE, FALSE, TRUE)`, and then selects the elements of `x` corresponding to the `TRUE` values.

We can use `==` to mimic the previous method of indexing by name (remember you have to use `==` rather than `=` for comparisons):

```{r}
x[names(x) == "a"]
```

It's helpful to understand that a logical vector can also be expressed as a numerical index by using the `which()` function, which returns the numerical index of each `TRUE` value.
```{r}
which(bool)
```

> ## Tip: Combining logical conditions
>
> We often want to combine multiple logical
> criteria. For example, we might want to find all the countries that are
> located in Asia **or** Europe **and** have life expectancies within a certain
> range. Several operations for combining logical vectors exist in R:
>
>  * `&`, the "logical AND" operator: returns `TRUE` if both the left and right
>    are `TRUE`.
>  * `|`, the "logical OR" operator: returns `TRUE`, if either the left or right
>    (or both) are `TRUE`.
>
> You may sometimes see `&&` and `||` instead of `&` and `|`. These two-character operators
> only look at the first element of each vector and ignore the
> remaining elements. In general you should not use the two-character
> operators in data analysis; save them
> for control flow, i.e. deciding whether to execute a statement.
>
>  * `!`, the "logical NOT" operator: converts `TRUE` to `FALSE` and `FALSE` to
>    `TRUE`. It can negate a single logical condition (eg `!TRUE` becomes
>    `FALSE`), or a whole vector of conditions(eg `!c(TRUE, FALSE)` becomes
>    `c(FALSE, TRUE)`).
>
> Additionally, you can compare the elements within a single vector using the
> `all` function (which returns `TRUE` if every element of the vector is `TRUE`)
> and the `any` function (which returns `TRUE` if one or more elements of the
> vector are `TRUE`).
{: .callout}


## Logicals for strings and factors

For matching a vector to single item, we can use the `==` or `!=` (not-equals) operator to construct a logical vector that will do what we want:

```{r}
x[names(x) == "a"]
x[names(x) != "a"]
```

Matching multiple named indices uses a special operator `%in%`. The `%in%` operator goes through each element of its left argument, in this case the names of `x`, and asks, "Does this element occur in the second argument?".

```{r}
x[! names(x) %in% c("a","c") ]
```

**Tip**: regardless of what is filtered out from a factor, the original levels 
are still preserved. To drop unused levels, use the `fct_drop()` from the "forcats" package. 


## Logical Indexing for Data frames

Using logical indexes in data frames is similar to how they are used in vectors. A boolean vector must match the length of what is being compared. Most often, this is the number of rows.

Using the historical hay dataset from NASS, let's filter for data from Idaho:

```{r}
hay <- read.csv("data/historical_hay_data.csv")
str(hay)
```

First, filter for the condition. Next, use the resultant logical vector to select the relevant data from the frame and assign the results. 

```{r}
index <- hay$state == "Idaho"
table(index)
hay_ida <- hay[index, ]
```
These steps can be combined:
```
hay_ida <- hay[hay$state == "Idaho", ]
```
Many steps can be combined:
```{r}
hay_pnw <- hay[hay$state %in% c("Idaho", "Washington", "Oregon") & hay$year > 1970, ]
hay_high <- hay[hay$yield > 2 | hay$acres > 2e6, ]
```

## Handling special values

At some point you will encounter functions in R that cannot handle missing, infinite,
or undefined data.

There are a number of special functions you can use to filter out this data:

 * `is.na` will return all positions in a vector, matrix, or data.frame
   containing `NA` (or `NaN`)
 * likewise, `is.nan`, and `is.infinite` will do the same for `NaN` and `Inf`.
 * `is.finite` will return all positions in a vector, matrix, or data.frame
   that do not contain `NA`, `NaN` or `Inf`.
 * `na.omit` will filter out all missing values from a vector
