---
title: Functions Explained
teaching: 20
exercises: 20
questions:
- "How can I write a new function in R?"
objectives:
- "Define a function that takes arguments."
- "Return a value from a function."
- "Check argument conditions with `stopifnot()` in functions."
- "Test a function."
- "Set default values for function arguments."
- "Explain why we should divide programs into small, single-purpose functions."
keypoints:
- "Use `function` to define a new function in R."
- "Use parameters to pass values into functions."
- "Use `stopifnot()` to flexibly check function arguments in R."
- "Load functions into programs using `source()`."
source: Rmd
---

If we only had one data set to analyze, it would probably be faster to load the file into a spreadsheet and use that to plot simple statistics. However, most of us have dynamic data sets that are under improvement for a long while. We are likely to want to examine the data repeatedly throughout the life of a project. We may also obtain similar data from a different source in the future and want to repeat some or all analysis steps. 

In this lesson, we'll learn how to write a function so that we can repeat several operations with a single command.

> ## What is a function?
>
> Functions gather a sequence of operations into a whole, preserving it for
> ongoing use. Functions provide:
>
> * a name we can remember and invoke it by
> * relief from the need to remember the individual operations
> * a defined set of inputs and expected outputs
> * rich connections to the larger programming environment
>
> As the basic building block of most programming languages, user-defined
> functions constitute "programming" as much as any single abstraction can. If
> you have written a function, you are a computer programmer.
{: .callout}

## Defining a function

Let's open a new R script file in the `functions/` directory and call it functions-lesson.R.

Let's define a function `fahr_to_celsius()` that converts temperatures from Fahrenheit to Celsius:

```{r}
fahr_to_celsius <- function(temp) {
  celsius <- ((temp - 32) * (5 / 9)) 
  return(celsius)
}
```

We define `fahr_to_celsius()` by assigning it to the output of `function`. The list of argument names ("temp") are contained within parentheses. Next, the [body]({{ page.root }}/reference/#function-body) of the function--the statements that are executed when it runs--is contained within curly braces (`{}`). The statements in the body are indented by two spaces. This makes the
code easier to read but does not affect how the code operates.

It is useful to think of creating functions like writing a cookbook. First you define the "ingredients" that your function needs. In this case, we only need one ingredient to use our function: "temp". After we list our ingredients, we then say what we will do with them, in this case, we are taking our ingredient and applying a set of mathmatical operators to it. 

When we call the function, the values we pass to it as arguments are assigned to those variables so that we can use them inside the function. Inside the function, we use a [return statement]({{ page.root }}/reference/#return-statement) to send a result back to whomever asked for it.

> ## Tip
>
> One feature unique to R is that the return statement is not required.
> R automatically returns whichever variable is on the last line of the body
> of the function. But for clarity, we will explicitly define the
> return statement.
{: .callout}


Let's try running our function. Calling our own function is no different from calling any other function:

```{r}
# freezing point of water
fahr_to_celsius(32)
```

```{r}
# boiling point of water
fahr_to_celsius(212)
```

## Combining functions

The real power of functions comes from mixing, matching and combining them into ever-larger chunks to get the effect we want.

Let's define another function that will convert temperature from Celsius to
Kelvin:

```{r}
celsius_to_kelvin <- function(temp) {
  kelvin <- temp + 273.15
}
```

Next, we will define a function to convert directly from Fahrenheit to Kelvin by reusing the two temperature conversions functions.
```{r}
fahr_to_kelvin <- function(temp) {
  temp_c <- fahr_to_celsius(temp)
  celsius_to_kelvin(temp_c)
}
```

These are some rather simple toy examples that could be accomplished by vectorised operations. Nevertheless, I have found functions to be a highly useful toolset for operations that need to repeated. The general rule for DRY principles (don't repeat yourself) is when you do something 3 or more times, it might be worth writing a function for it. 

Function writing is a topic we will revisit through this workshops because it is essence of efficient and reproducible programming. 

## Interlude: Defensive Programming

Now that we've begun to appreciate how writing functions provides an efficient way to make R code re-usable and modular, we should note that it is important to ensure that functions only work in their intended use-cases. Checking function parameters is related to the concept of _defensive programming_. Defensive programming encourages us to frequently check conditions and throw an error if something is wrong. These checks are referred to as assertion statements because we want to assert some condition is `TRUE` before proceeding. They make it easier to debug because they give us a better idea of where the errors originate.

### Checking conditions with `stopifnot()`

Let's start by re-examining `fahr_to_kelvin()`, our function for converting temperatures from Fahrenheit to Kelvin. It was defined like so:

```{r}
fahr_to_kelvin <- function(temp) {
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  return(kelvin)
}
```

For this function to work as intended, the argument `temp` must be a `numeric` value; otherwise, the mathematical procedure for converting between the two temperature scales will not work. To create an error, we can use the function `stop()`. For example, since the argument `temp` must be a `numeric` vector, we could check for this condition with an `if` statement and throw an error if the condition was violated. We could augment our function above like so:

```{r}
fahr_to_kelvin <- function(temp) {
  if (!is.numeric(temp)) {
    stop("temp must be a numeric vector.")
  }
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  return(kelvin)
}
```

If we had multiple conditions or arguments to check, it would take many lines
of code to check all of them. Luckily R provides the convenience function
`stopifnot()`. We can list as many requirements that should evaluate to `TRUE`;
`stopifnot()` throws an error if it finds one that is `FALSE`. Listing these
conditions also serves a secondary purpose as extra documentation for the
function.

Let's try out defensive programming with `stopifnot()` by adding assertions to
check the input to our function `fahr_to_kelvin()`.

We want to assert the following: `temp` is a numeric vector. We may do that like
so:

```{r}
fahr_to_kelvin <- function(temp) {
  stopifnot(is.numeric(temp))
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  return(kelvin)
}
```

It still works when given proper input.

```{r}
# freezing point of water
fahr_to_kelvin(temp = 32)
```

But fails instantly if given improper input.

```{r}
# Metric is a factor instead of numeric
fahr_to_kelvin(temp = as.factor(32))
```


If you've been writing these functions down into a separate R script (a good idea), you can load in the functions into our R session by using the `source()` function:

```{}
source("path-to-my-function/my_functions.R")
```

> ## Tip: Function scope
>
> Another important concept is scoping: any variables (or functions!) you
> create or modify inside the body of a function only exist for the lifetime
> of the function's execution. When we call `fahr_to_kelvin()`, the variable
> `kelvin` only exists inside the body of the function. Even if we
> have variables of the same name in our interactive R session, they are
> not modified in any way when executing a function.
{: .callout}

> ## Tip
>
> R has some unique aspects that can be exploited when performing more
> complicated operations. We will not be writing anything that requires
> knowledge of these more advanced concepts. In the future when you are
> comfortable writing functions in R, you can learn more by reading the
> [R Language Manual][man] or this [chapter][] from
> [Advanced R Programming][adv-r] by Hadley Wickham.
{: .callout}

[man]: http://cran.r-project.org/doc/manuals/r-release/R-lang.html#Environment-objects
[chapter]: http://adv-r.had.co.nz/Environments.html
[adv-r]: http://adv-r.had.co.nz/

> ## Tip: Testing and documenting
>
> It's important to both test functions and document them:
> Documentation helps you, and others, understand what the
> purpose of your function is, and how to use it, and its
> important to make sure that your function actually does
> what you think.
>
> When you first start out, your workflow will probably look a lot
> like this:
>
>  1. Write a function
>  2. Comment parts of the function to document its behaviour
>  3. Load in the source file
>  4. Experiment with it in the console to make sure it behaves
>     as you expect
>  5. Make any necessary bug fixes
>  6. Rinse and repeat.
>
> Formal documentation for functions, written in separate `.Rd`
> files, gets turned into the documentation you see in help
> files. The [roxygen2][] package allows R coders to write documentation
> alongside the function code and then process it into the appropriate `.Rd`
> files. You will want to switch to this more formal method of writing
> documentation when you start writing more complicated R projects.
>
> Formal automated tests can be written using the [testthat][] package.
{: .callout}

[roxygen2]: http://cran.r-project.org/web/packages/roxygen2/vignettes/rd.html
[testthat]: http://r-pkgs.had.co.nz/tests.html

